# Rate-Limiter
最近遇到一个场景，在每分钟错误计数达到250时发送消息。这里的每分钟并不是说整点的几分，有可能是现在16：16：16到16：17：16。

Leaky Bucket的思想是认为有一个会漏水的桶，水以恒定速率滴出，上方会有水滴（请求）进入水桶。显然，如果上方水滴进入速率超过水滴出的速率，那么水桶就会溢出，这里的溢出就是traffic shaping和traffic policing的条件，即执行某个过载任务的时候。

Token Bucket的思想是同样有一个桶，令牌以恒定速率放入桶，桶内的令牌数有上限，每个请求会acquire一个令牌，如果某个请求来到而桶内没有令牌了，请说明这个请求是过载的。和Lecky Bucket不同的是，Token Bucket存在burst rate。比如当前令牌放入速率4个每秒，桶的令牌上限是8，第一秒内没有请求，第二秒实际就可以处理8个请求！虽然平均速率还是4个每秒，但是爆发速率是8个每秒。

两个算法的实现上，Leaky Bucket还分meter和queue，meter看起来需要定时器辅助，queue不太符合我的需求。Token Bucket虽然有burst rate，但是只要调整为和rate一样就可以了，而且实现起来不需要定时器。
Token Bucket的实现原理是计算请求时间和上一次请求时间之间内增加的令牌数放入桶，比较桶内的令牌数是否足够用于请求，如果不够就认为过载，否则减去响应令牌，设置上一次请求时间为本次请求时间。注意下面的take方法实现，虽然只有不到十行，但准确地解决了请求速度限制问题。
